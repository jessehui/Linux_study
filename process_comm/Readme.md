# 进程间通信

1. 进程控制: 调用fork函数创建进程. 创建的两个进程, 在`用户空间`是不可能进行通信的. 只能在内核空间通信. 线程相当于房间, 可以实现用户空间的通信. 
2. "unistd.h" 是 C 和 C++ 程序设计语言中提供对 POSIX 操作系统 API 的访问功能的头文件的名称。是Unix Standard的缩写。该头文件由 POSIX.1 标准（单一UNIX规范的基础）提出，故所有遵循该标准的操作系统和编译器均应提供该头文件（如 Unix 的所有官方版本，包括 Mac OS X、Linux 等）。  
对于类 Unix 系统，unistd.h 中所定义的接口通常都是大量针对系统调用的封装（英语：wrapper functions），如 fork、pipe 以及各种 I/O 原语（read、write、close 等等）。
3. sys/types.h，中文名称为基本系统数据类型，此头文件还包含适当时应使用的多个基本派生类型。用  
`locate sys/types.h`定位该头文件位置.
4. 函数名: sleep  
头文件: #include <windows.h> // 在VC中使用带上头文件  
        #include <unistd.h>  // 在gcc编译器中，使用的头文件因gcc版本的不同而不同  
功  能: 执行挂起指定的秒数  
语  法: unsigned sleep(unsigned seconds);  

函数名: usleep  
头文件: #include <unistd.h>  
功  能: usleep功能把进程挂起一段时间， 单位是微秒（百万分之一秒）；  
语  法: void usleep(int micro_seconds);  
返回值: 无  
内容说明：本函数可暂时使程序停止执行。参数 micro_seconds 为要暂停的微秒数(us)。  
注 意：  
这个函数不能工作在windows 操作系统中。用在Linux的测试环境下面。  
参 见:usleep() 与sleep()类似，用于延迟挂起进程。进程被挂起放到reday queue。  
是一般情况下，延迟时间数量级是秒的时候，尽可能使用sleep()函数。  
如果延迟时间为几十毫秒（1ms = 1000us），或者更小，尽可能使用usleep()函数。这样才能最佳的利用CPU时间  


5. 用gcc编译使用了POSIX thread的程序时通常需要加额外的选项，以便使用thread-safe的库及头文件.  
 `gcc -o thread_test thread_test.c -pthread`

6. 进程间通信三种(单机, 同一个内核下): 
- 管道通信: 有名管道, 无名管道. 
- 信号通信: 信号的发送, 接收, 处理
- IPC通信(Inter-Process Communication): 共享内存 消息队列 信号灯

还有socket通信: 一个网络中两个进程之间的通信.   
但是每一种通信方式 都是基于文件IO思想的. 

7. 无名管道: 在文件系统中 无文件节点或者文件名.   
有名管道: 文件系统中有文件名和文件节点.  管道文件是一种特殊的文件, 是用队列来实现的(入队就是写, 出队就是读). 因为它特殊, 所以不能用`open()`函数来创建. 因为open()函数只能创建普通文件.   
```c
int pipe(int fd[2]);    //创建管道 为系统调用 需要<unistd.h>
//参数: 就是得到的文件描述符
//返回0: 成功 返回-1: 失败


//open 函数
int fd = open(argv[1],//文件名，路径
          O_CREAT | O_RDWR, // 表示新建一个文件 同时可以以读写方式打开
          777); // 新建文件的权限 777 所有可读可执行可写
//返回文件描述符
```

看pipe函数的参数是两个文件描述符`fd[0]` 和 `fd[1]`, 其实也是管道创建后的两头. 读端是fd[0], 写端是fd[1], 规则不能变. 然后就可以用`read()`, `write()`函数来读或者写东西了. 

注意:  
- 进程调用pipe函数陷入内核.
- 管道是创建在内存中的. 进程结束, 内存释放, 管道就不存在了.
- 管道中的东西, 读完就自动删除了.
- 管道还有写阻塞. 当把系统开辟的管道空间写满时,就进入写阻塞状态. 

无名通道的缺点: 不能实现非父子进程间的通信. 注意管道建立在fork之前(pipe函数在fork函数之前). 


8. 有名管道
文件类型: 管道文件 ( 标示为p, Linux的另外三种文件类型: 普通文件(-), 目录文件(d), 链接文件(l))
函数: mkfifo 创建管道文件
```c
//函数形式
int mkfifo(const char*filename, mode_t mode)
```
参数: 管道文件文件名, 权限, 权限依然和umask有关   
返回值: 创建成功返回0, 失败返回-1  
管道文件不占磁盘空间. 除了它还有字符设备, 块设备, 套接字. 只有文件节点. 

用open函数不能创建 但是可以打开管道文件. 
当用open函数打开管道时, 如果读端不存在的时候 写端也不会继续运行.

管道在内存中是以队列形式出现的. 

9. 信号通信
用信号对象交流. 信号在内核中是已经存在了的. 利用`kill -l`指令可以看到linux内核可以发送的信号种类, 一共64种.   
`kill 9`命令可以杀死一个用户空间进程. `9`就是一个信号的ID, 是`SIGKILL`宏. `kill 9 pid`表示杀死对应pid的进程.   
其实`kill`就是一个利用信号通信的例子. 

```c
#include <signal.h>
#include <sys/types.h>

int kill(pid_t pid, int sig);

```

pid:  
- 正数: 要接收信号的进程的进程号
- 0: 信号被发送到所有和pid进程在同一个进程组的进程
- -1: 信号发给所有的进程表中的进程, 除了进程号最大的进程外

返回值:   
- 0:成功
- -1: 出错

`raise()`函数: 发信号给自己 


10. 信号接收和处理
一般可以采用`pause()`,`sleep()`, `while(1)`等. 处理时采用`signal()`函数.  
SIGTSTP信号, 该信号用于暂停交互进程. 

`waitpid()`:   
waitpid()会暂时停止目前进程的执行, 直到有信号来到或子进程结束. 如果在调用wait()时子进程已经结束, 则wait()会立即返回子进程结束状态值. 子进程的结束状态值会由参数status 返回, 而子进程的进程识别码也会一快返回. 如果不在意结束状态值, 则参数status 可以设成NULL. 参数pid 为欲等待的子进程识别码, 其数值意义如下：
(1) pid<-1 等待进程组识别码为pid 绝对值的任何子进程.
(2) pid=-1 等待任何子进程, 相当于wait().
(3) pid=0 等待进程组识别码与目前进程相同的任何子进程.
(4) pid>0 等待任何子进程识别码为pid 的子进程.

WNOHANG：如果没有任何已经结束的子进程则马上返回, 不予以等待.

返回值：如果执行成功则返回子进程识别码(PID), 如果有错误发生则返回-1. 

11. alarm函数
闹钟函数, 只会发一种信号. 即`SIGALRM`. 该信号当一个定时器到时的时候发出. 默认操作是终止进程.  
alarm和raise和kill的区别是调用成功后会延迟一段时间. 
```c
unsigned int alarm(unsigned int seconds);
//seconds: 指定的延迟时间.

```
















